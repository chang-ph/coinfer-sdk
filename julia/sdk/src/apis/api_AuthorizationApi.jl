# This file was generated by the Julia OpenAPI Code Generator
# Do not modify this file directly. Modify the OpenAPI specification instead.

struct AuthorizationApi <: OpenAPI.APIClientImpl
    client::OpenAPI.Clients.Client
end

"""
The default API base path for APIs in `AuthorizationApi`.
This can be used to construct the `OpenAPI.Clients.Client` instance.
"""
basepath(::Type{ AuthorizationApi }) = "https://api.coinfer.ai"

const _returntypes_access_token_AuthorizationApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => SuccRspCode2TokenRsp,
    Regex("^" * replace("400", "x"=>".") * "\$") => ErrRsp,
)

function _oacinternal_access_token(_api::AuthorizationApi; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_access_token_AuthorizationApi, "/base/access_token", ["GlobalAuth", ])
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Access Token

Get access token.

Params:

Return: SuccRspCode2TokenRsp, OpenAPI.Clients.ApiResponse
"""
function access_token(_api::AuthorizationApi; _mediaType=nothing)
    _ctx = _oacinternal_access_token(_api; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function access_token(_api::AuthorizationApi, response_stream::Channel; _mediaType=nothing)
    _ctx = _oacinternal_access_token(_api; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_auth0_config_AuthorizationApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => SuccRspAuth0ConfigRsp,
)

function _oacinternal_auth0_config(_api::AuthorizationApi; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_auth0_config_AuthorizationApi, "/base/auth0-config", [])
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Get Auth0 login configuration

Returns the configurations need by the frontend to implement Auth0 login. By using an API to provide this information, we avoid hardcoding them in the frontend code.  This API doen't need authorization as it is usually called before login.

Params:

Return: SuccRspAuth0ConfigRsp, OpenAPI.Clients.ApiResponse
"""
function auth0_config(_api::AuthorizationApi; _mediaType=nothing)
    _ctx = _oacinternal_auth0_config(_api; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function auth0_config(_api::AuthorizationApi, response_stream::Channel; _mediaType=nothing)
    _ctx = _oacinternal_auth0_config(_api; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_auth0_login_AuthorizationApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => SuccRspAuth0LoginRsp,
)

function _oacinternal_auth0_login(_api::AuthorizationApi; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_auth0_login_AuthorizationApi, "/base/auth0-login", [])
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Login with Auth0.

This API should be called after the user finishes the Auth0 authorization. So the frontend should be able to obtain an Auth0 token at that point. The API should be called with this token in the `Authorization` header, in the format like `Authorization: Bearer <token>`.  The API will call an Auth0 API to query user information with the token. If it successfully gets it, it means the token is valid. Then the API will either:  1. Retrieve the user object within our system 2. Create a new user within our system  depending on whether a user with the same identity exists in our system.  If everything is okay, the API will return a token which can then be used as an identification to call other APIs. The return format is intentionally designed to keep the same as password login API.

Params:

Return: SuccRspAuth0LoginRsp, OpenAPI.Clients.ApiResponse
"""
function auth0_login(_api::AuthorizationApi; _mediaType=nothing)
    _ctx = _oacinternal_auth0_login(_api; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function auth0_login(_api::AuthorizationApi, response_stream::Channel; _mediaType=nothing)
    _ctx = _oacinternal_auth0_login(_api; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_code2token_AuthorizationApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => SuccRspCode2TokenRsp,
    Regex("^" * replace("400", "x"=>".") * "\$") => ErrRsp,
)

function _oacinternal_code2token(_api::AuthorizationApi, code::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_code2token_AuthorizationApi, "/base/code2token", ["GlobalAuth", ])
    OpenAPI.Clients.set_param(_ctx.form, "code", code)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/x-www-form-urlencoded", ] : [_mediaType])
    return _ctx
end

@doc raw"""Code2Token

Exchange code for access token.

Params:
- code::String (required)

Return: SuccRspCode2TokenRsp, OpenAPI.Clients.ApiResponse
"""
function code2token(_api::AuthorizationApi, code::String; _mediaType=nothing)
    _ctx = _oacinternal_code2token(_api, code; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function code2token(_api::AuthorizationApi, response_stream::Channel, code::String; _mediaType=nothing)
    _ctx = _oacinternal_code2token(_api, code; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_create_token_AuthorizationApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => SuccRspGetTokensRsp,
    Regex("^" * replace("400", "x"=>".") * "\$") => ErrRsp,
)

function _oacinternal_create_token(_api::AuthorizationApi; create_token_param=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_create_token_AuthorizationApi, "/base/user/tokens", ["GlobalAuth", ], create_token_param)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Create a new authorization token.

This is where the user explicitly creates a new token. The token can be used to call other APIs in the name of the user.

Params:
- create_token_param::CreateToken

Return: SuccRspGetTokensRsp, OpenAPI.Clients.ApiResponse
"""
function create_token(_api::AuthorizationApi; create_token_param=nothing, _mediaType=nothing)
    _ctx = _oacinternal_create_token(_api; create_token_param=create_token_param, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function create_token(_api::AuthorizationApi, response_stream::Channel; create_token_param=nothing, _mediaType=nothing)
    _ctx = _oacinternal_create_token(_api; create_token_param=create_token_param, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_delete_linked_account_AuthorizationApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => SuccRspSoftDeletedRsp,
    Regex("^" * replace("400", "x"=>".") * "\$") => ErrRsp,
)

function _oacinternal_delete_linked_account(_api::AuthorizationApi; deleted_key=nothing, accounts=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "DELETE", _returntypes_delete_linked_account_AuthorizationApi, "/base/linked-account", ["GlobalAuth", ])
    OpenAPI.Clients.set_param(_ctx.query, "deleted_key", deleted_key; style="form", is_explode=true)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "accounts", accounts; style="form", is_explode=true)  # type Vector{String}
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Delete Linked Account

Delete a linked account.

Params:
- deleted_key::String
- accounts::Vector{String}

Return: SuccRspSoftDeletedRsp, OpenAPI.Clients.ApiResponse
"""
function delete_linked_account(_api::AuthorizationApi; deleted_key=nothing, accounts=nothing, _mediaType=nothing)
    _ctx = _oacinternal_delete_linked_account(_api; deleted_key=deleted_key, accounts=accounts, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function delete_linked_account(_api::AuthorizationApi, response_stream::Channel; deleted_key=nothing, accounts=nothing, _mediaType=nothing)
    _ctx = _oacinternal_delete_linked_account(_api; deleted_key=deleted_key, accounts=accounts, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_delete_token_AuthorizationApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => SuccRspNoneType,
    Regex("^" * replace("400", "x"=>".") * "\$") => ErrRsp,
)

function _oacinternal_delete_token(_api::AuthorizationApi, token_id::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "DELETE", _returntypes_delete_token_AuthorizationApi, "/base/user/token/{token_id}", ["GlobalAuth", ])
    OpenAPI.Clients.set_param(_ctx.path, "token_id", token_id)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Delete a token by its ID.

Delete(invalidate) a token.

Params:
- token_id::String (required)

Return: SuccRspNoneType, OpenAPI.Clients.ApiResponse
"""
function delete_token(_api::AuthorizationApi, token_id::String; _mediaType=nothing)
    _ctx = _oacinternal_delete_token(_api, token_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function delete_token(_api::AuthorizationApi, response_stream::Channel, token_id::String; _mediaType=nothing)
    _ctx = _oacinternal_delete_token(_api, token_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_get_tokens_AuthorizationApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => SuccRspListGetTokensRsp,
    Regex("^" * replace("400", "x"=>".") * "\$") => ErrRsp,
)

function _oacinternal_get_tokens(_api::AuthorizationApi; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_get_tokens_AuthorizationApi, "/base/user/tokens", ["GlobalAuth", ])
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""List all of current user's tokens.

Get the tokens created by the current user.  In our system, there are two kinds of tokens:  1. Tokens created explicitly by user. 2. Tokens created implicitly when a user logs in.  This API only returns the former. The latter should be seen as implementation detail and be invisible to the user.

Params:

Return: SuccRspListGetTokensRsp, OpenAPI.Clients.ApiResponse
"""
function get_tokens(_api::AuthorizationApi; _mediaType=nothing)
    _ctx = _oacinternal_get_tokens(_api; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function get_tokens(_api::AuthorizationApi, response_stream::Channel; _mediaType=nothing)
    _ctx = _oacinternal_get_tokens(_api; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_list_linked_account_AuthorizationApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => SuccRspListLinkedAccountRsp,
    Regex("^" * replace("400", "x"=>".") * "\$") => ErrRsp,
)

function _oacinternal_list_linked_account(_api::AuthorizationApi; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_list_linked_account_AuthorizationApi, "/base/linked-account", ["GlobalAuth", ])
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""List Linked Account

Get list of linked account.

Params:

Return: SuccRspListLinkedAccountRsp, OpenAPI.Clients.ApiResponse
"""
function list_linked_account(_api::AuthorizationApi; _mediaType=nothing)
    _ctx = _oacinternal_list_linked_account(_api; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function list_linked_account(_api::AuthorizationApi, response_stream::Channel; _mediaType=nothing)
    _ctx = _oacinternal_list_linked_account(_api; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_modify_current_user_AuthorizationApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => SuccRspUserInfoRsp,
    Regex("^" * replace("400", "x"=>".") * "\$") => ErrRsp,
)

function _oacinternal_modify_current_user(_api::AuthorizationApi, modify_current_user_param::ModifyCurrentUser; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "PUT", _returntypes_modify_current_user_AuthorizationApi, "/base/user", ["GlobalAuth", ], modify_current_user_param)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Update information of current user.

Modify the property of the current logined user. Currently only login password is supported.

Params:
- modify_current_user_param::ModifyCurrentUser (required)

Return: SuccRspUserInfoRsp, OpenAPI.Clients.ApiResponse
"""
function modify_current_user(_api::AuthorizationApi, modify_current_user_param::ModifyCurrentUser; _mediaType=nothing)
    _ctx = _oacinternal_modify_current_user(_api, modify_current_user_param; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function modify_current_user(_api::AuthorizationApi, response_stream::Channel, modify_current_user_param::ModifyCurrentUser; _mediaType=nothing)
    _ctx = _oacinternal_modify_current_user(_api, modify_current_user_param; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_modify_token_AuthorizationApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => SuccRspGetTokensRsp,
    Regex("^" * replace("400", "x"=>".") * "\$") => ErrRsp,
)

function _oacinternal_modify_token(_api::AuthorizationApi, token_id::String, modify_token_param::ModifyToken; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "PUT", _returntypes_modify_token_AuthorizationApi, "/base/user/token/{token_id}", ["GlobalAuth", ], modify_token_param)
    OpenAPI.Clients.set_param(_ctx.path, "token_id", token_id)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Update a token by its ID.

Modify various property of a token.

Params:
- token_id::String (required)
- modify_token_param::ModifyToken (required)

Return: SuccRspGetTokensRsp, OpenAPI.Clients.ApiResponse
"""
function modify_token(_api::AuthorizationApi, token_id::String, modify_token_param::ModifyToken; _mediaType=nothing)
    _ctx = _oacinternal_modify_token(_api, token_id, modify_token_param; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function modify_token(_api::AuthorizationApi, response_stream::Channel, token_id::String, modify_token_param::ModifyToken; _mediaType=nothing)
    _ctx = _oacinternal_modify_token(_api, token_id, modify_token_param; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_user_info_AuthorizationApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => SuccRspUserInfoRsp,
    Regex("^" * replace("401", "x"=>".") * "\$") => ErrRsp,
    Regex("^" * replace("400", "x"=>".") * "\$") => ErrRsp,
)

function _oacinternal_user_info(_api::AuthorizationApi; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_user_info_AuthorizationApi, "/base/user", ["GlobalAuth", ])
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Get information of current user.

Returns the information of the current logined user.

Params:

Return: SuccRspUserInfoRsp, OpenAPI.Clients.ApiResponse
"""
function user_info(_api::AuthorizationApi; _mediaType=nothing)
    _ctx = _oacinternal_user_info(_api; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function user_info(_api::AuthorizationApi, response_stream::Channel; _mediaType=nothing)
    _ctx = _oacinternal_user_info(_api; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_user_login_AuthorizationApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => SuccRspUserLoginRsp,
    Regex("^" * replace("400", "x"=>".") * "\$") => ErrRsp,
)

function _oacinternal_user_login(_api::AuthorizationApi, user_login_param::UserLogin; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_user_login_AuthorizationApi, "/base/login", [], user_login_param)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Login with password.

Login in with user name and password.  On success, the return value of the API will be a token which can then be used as an identification to call other APIs.

Params:
- user_login_param::UserLogin (required)

Return: SuccRspUserLoginRsp, OpenAPI.Clients.ApiResponse
"""
function user_login(_api::AuthorizationApi, user_login_param::UserLogin; _mediaType=nothing)
    _ctx = _oacinternal_user_login(_api, user_login_param; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function user_login(_api::AuthorizationApi, response_stream::Channel, user_login_param::UserLogin; _mediaType=nothing)
    _ctx = _oacinternal_user_login(_api, user_login_param; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_user_logout_AuthorizationApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => SuccRspNoneType,
    Regex("^" * replace("400", "x"=>".") * "\$") => ErrRsp,
)

function _oacinternal_user_logout(_api::AuthorizationApi; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_user_logout_AuthorizationApi, "/base/logout", ["GlobalAuth", ])
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Logout the system.

Log out of the system.

Params:

Return: SuccRspNoneType, OpenAPI.Clients.ApiResponse
"""
function user_logout(_api::AuthorizationApi; _mediaType=nothing)
    _ctx = _oacinternal_user_logout(_api; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function user_logout(_api::AuthorizationApi, response_stream::Channel; _mediaType=nothing)
    _ctx = _oacinternal_user_logout(_api; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

export access_token
export auth0_config
export auth0_login
export code2token
export create_token
export delete_linked_account
export delete_token
export get_tokens
export list_linked_account
export modify_current_user
export modify_token
export user_info
export user_login
export user_logout
